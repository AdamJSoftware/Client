import socket
import sys
from threading import Thread
import time
from pyautogui import press, typewrite, hotkey
import selectors
sel = selectors.DefaultSelector()
import types
import os
import uuid
global connected

global dict

global skip
global a
global b
global sock1
global sock2
global In_Messaging
global enter
global back_message
global back
global ComputerList
global message
import csv
global go_back
global key
global sock2
global break_all


break_all = False

back = False
message = False

show_ls = True

ComputerList = []


go_back = False

dict = {}

results = []

sock1 = None
sock2 = None
skip = 1

connected = False
enter = False


def accept_wrapper(sock):
    global break_all
    if not str(sock).__contains__('[closed]'):
        conn, addr = sock.accept()  # Should be ready to read
        print('accepted connection from', addr)
        conn.setblocking(False)
        data = types.SimpleNamespace(addr=addr, inb=b'', outb=b'')
        events = selectors.EVENT_READ | selectors.EVENT_WRITE
        sel.register(conn, events, data=data)
        if break_all == True:
            print('breaking')
            return




def service_connection(key, mask):
    global sock
    global sock1
    global sock2
    global connected
    global In_Messaging
    global new_client
    global enter
    global back
    global show_ls
    global dict
    global break_all
    sock = key.fileobj
    sock2 = sock
    data = key.data
    if break_all == True:
        return
    if not str(sock).__contains__('[closed]'):
        if not str(sock).__contains__('[closed]'):
            if sock not in dict.values():
                if not str(sock).__contains__('[closed]'):
                    new_client = True
                    random = str(uuid.uuid4())
                    random = random[:4]
                    random = 'temporary' + str(random)
                    dict[str(random)] = sock
                    print(dict)
                    if len(dict) > 1:
                        with open('Profiles.csv', 'r') as f:
                            print("Please wait for system to configure new computer...")
                            if break_all == True:
                                return
                            try:
                                time.sleep(4)
                                Computer_Name = sock.recv(1024).decode()
                            except:
                                Computer_Name = "failed"
                            results = f.readlines()
                            mystring = ''.join(results)
                            newstring = mystring.split(',')
                            length = len(newstring)
                            length = length - 1
                            i = 0
                            detected = False
                            while i != length:
                                Name = newstring[i]
                                i += 1
                                PC_Name = newstring[i]
                                i += 1
                                print(Name + " - " + PC_Name)
                                print(Computer_Name)
                                print(PC_Name)
                                if Computer_Name == PC_Name:
                                    print('detected -> ' + Name + " -> Hostname -> " + PC_Name)
                                    detected = True
                                    print(dict)
                                    del dict[random]
                                    if Name in dict:
                                        print("Computer with same hostname found. Creating temporary name for client...")
                                        random = str(uuid.uuid4())
                                        random = random[:4]
                                        Name = Name + str(random)
                                        show_ls = True
                                    else:
                                        show_ls = True
                                    if show_ls == True:
                                        dict[Name] = sock
                                        show_ls = False
                                        ls_func()
                                    print(dict)
                                    new_client = False
                                    if In_Messaging == True:
                                        back_func()
                                    else:
                                        enter_func()
                                    i = length

                                if Computer_Name == "failed":
                                    print('could not get hostname. Assigning random value for computer')
                                    detected = True
                                    print(dict)
                                    try:
                                        del dict[random]
                                        random = str(uuid.uuid4())
                                        random = random[:4]
                                        Name = "COMPUTER" + str(random)
                                        show_ls = True
                                        if show_ls == True:
                                            dict[Name] = sock
                                            show_ls = False
                                            ls_func()
                                        print(dict)
                                        new_client = False
                                        if In_Messaging == True:
                                            back_func()
                                        else:
                                            enter_func()
                                        i = length
                                    except:
                                        print('Error connecting. Device may need to restart')


                            if detected == False:
                                print('New computer detected. Please wait for system to configure')
                                time.sleep(1)
                                enter = True
                                one = input("What is the name of this computer: ")
                                del dict[random]
                                dict[one] = sock
                                print(dict)
                                new_client = False
                                if In_Messaging == True:
                                    back_func()
                                else:
                                    enter_func()
                    else:
                        with open('Profiles.csv', 'r') as f:
                            print("Please wait for system to configure new computer...")
                            time.sleep(2)
                            try:
                                time.sleep(4)
                                Computer_Name = sock.recv(1024).decode()
                            except:
                                Computer_Name = "failed"
                            results = f.readlines()
                            mystring = ''.join(results)
                            newstring = mystring.split(',')
                            length = len(newstring)
                            length = length - 1
                            i = 0
                            detected = False
                            while i != length:
                                Name = newstring[i]
                                i += 1
                                PC_Name = newstring[i]
                                print(PC_Name)
                                print(Computer_Name)
                                i += 1
                                print("Computer profile list: ")
                                print('\t' + Name + " - " + PC_Name)
                                if Computer_Name == PC_Name:
                                    print('detected -> ' + Name + " -> Hostname -> " + PC_Name)
                                    detected = True
                                    del dict[random]
                                    dict[Name] = sock
                                    print(dict)
                                    new_client = False
                                    i = length

                                try:
                                    if Computer_Name == "failed":
                                        print('could not get hostname. Assigning random value for computer')
                                        detected = True
                                        print(dict)
                                        try:
                                            del dict[random]
                                            random = str(uuid.uuid4())
                                            random = random[:4]
                                            Name = "COMPUTER" + str(random)
                                            show_ls = True
                                            if show_ls == True:
                                                dict[Name] = sock
                                                show_ls = False
                                                ls_func()
                                            print(dict)
                                            new_client = False
                                            if In_Messaging == True:
                                                back_func()
                                            else:
                                                enter_func()
                                            i = length
                                        except:
                                            print('Error connecting. Device may need to restart')
                                except:
                                    print("Am unexpected errpr occured. This could probably be ignored")


                            if detected == False:
                                one = input("What is the name of this computer: ")
                                del dict[random]
                                dict[one] = sock
                                new_client = False
                                with open(""
                                          "Profiles.csv", 'a', newline='') as resultFile:
                                    wr = csv.writer(resultFile, delimiter=',', lineterminator='\r')
                                    comma = ''
                                    row = [one, Computer_Name, comma]
                                    wr.writerow(row)

        '''except:
            print("error connecting to socket... Trying again")
            sock = "[closed]"
            if break_all == True:
                return'''
    else:
        print("declined" + str(sock))


    if connected == False:
        connected = True

    try:
        if mask & selectors.EVENT_READ:
            recv_data = sock.recv(1024).decode()  # Should be ready to read
            if recv_data != "--quit--":
                dictList = []
                [dictList.extend([k, v]) for k, v in dict.items()]
                Position = dictList.index(sock) - 1
                print('\n' + "Recieved message from -> " + dictList[Position] + " -> " + recv_data)
                enter = True
            else:
                print(dict)
                print('closing connection to', data.addr)
                sel.unregister(sock)
                sock.close()
                for x, y in dict.items():
                    if y == sock:
                        del dict[x]
                        break
                print(dict)
                if In_Messaging == True:
                    back_func()
                else:
                    enter_func()
    except:
        pass


def enter_func():
    global enter
    press('enter')
    enter = False

def message_func():
    global message
    time.sleep(.1)
    press('enter')
    message = False


def back_func():
    global back_message
    global back
    global In_Messaging
    print("Returning to main screen. Please hold")
    time.sleep(1)
    press('enter')
    time.sleep(1)
    back_message = "/back"
    back = True
    press('enter')
    In_Messaging = False
    go_back = False

def message_func(Q):
    global In_Messaging
    global back_message
    global back
    back = False
    back_message = ""
    length = len(dict)
    if length == 1:
        try:
            print('sending message to only connected client')
            for x in dict.values():
                while back_message != "/back":

                    if back == False:
                        In_Messaging = True
                        message = input(" -> ")
                        back_message = message
                        message = message.encode("utf-8")
                        sock1 = x
                        sock1.send(message)
                    else:
                        back_message = "/back"
                In_Messaging = False
        except:
            pass
    else:
        try:
            Q = Q.split('/m ', 1)[1]
            if Q in str(dict):
                back_message = ""
                while back_message != "/back":
                    if back == False:
                        In_Messaging = True
                        message = input("Sending message to -> " + Q + " -> ")
                        back_message = message
                        message = message.encode("utf-8")
                        sock1 = dict[Q]
                        sock1.send(message)
                    else:
                        back_message = "/back"
                In_Messaging = False
            else:
                print("Computer not found. Please reference the computer list:")
                ls_func()
        except:
            print("Here is the list of computers:")
            ls_func()


def ls_func():
    global dict
    for x in dict:
        print(x)


def help_func():
    print("/m - 'DEVICE NAME' --> Sends message to device, \n"
          "/m - all --> Sends message to all devices, \n"
          "/power 'DEVICE NAME' --> Turns on device, \n"
          "/shutdown 'DEVICE NAME' --> Shutsdown device, \n"
          "/ls --> Shows connected devices, \n"
          "/back --> Exists messaging menu, \n")


class Starter(Thread):
    global soc
    global data
    global new_data
    global enter
    global break_all

    def __init__(self):
        global soc
        global new_data
        global enter
        global break_all
        Thread.__init__(self)
        print("Starting server")
        self.running = True
        self.new_data = False

        host = ''
        port = 8888

        lsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

        try:
            lsock.bind((host, port))
        except:
            print("Bind failed. Error : " + str(sys.exc_info()))
            sys.exit()

        lsock.listen(5)
        print("Socket created")
        lsock.setblocking(False)
        sel.register(lsock,selectors.EVENT_READ, data=None)
        self.running = True


    def run(self):
        global enter
        global break_all
        while self.running:
            if break_all == True:
                print('breaking main')
                press('enter')
                return
            events = sel.select(timeout=None)
            for key, mask in events:
                if key.data is None:
                    if break_all == True:
                        print('breaking main')
                        return
                    accept_wrapper(key.fileobj)
                else:
                    if break_all == True:
                        print('breaking main')
                        return
                    service_connection(key, mask)


    def stop(self):
        self.running = False


class Send(Thread):
    global In_Messaging

    def __init__(self):
        Thread.__init__(self)
        global In_Messaging


    def run(self):
        global In_Messaging
        while True:
            In_Messaging = False
            Q = input(' -> ')
            self.Q = Q
            if Q == "":
                pass
            if Q == "/ls":
                ls_func()
            if Q == "/help":
                help_func()
            if Q.__contains__('/m'):
                message_func(Q)
            if Q == 'test':
                 i = len(dict)
                 i = 0
                 while i < len(dict):
                    check = list(dict.values())[i]
                    if str(check).__contains__('[closed]'):
                        print('problem found')
            if break_all == True:
                print('breaking Send')
                return


class Check(Thread):
    global enter
    global back
    global message
    global go_back
    global break_all
    global dict

    def __init__(self):
        global enter
        global back
        global message
        global break_all
        global dict
        Thread.__init__(self)
        print("Check thread started")

    def run(self):
        global enter
        global back
        global message
        global go_back
        global dict
        global break_all
        while True:
            if enter == True:
                enter_func()
            if go_back == True:
                back_func()
            if message == True:
                message_func()
            if break_all == True:
                print('breaking Check')
                return


class Check2(Thread):
    def __init__(self):
        global enter
        global back
        global message
        global dict
        global new_client
        global break_all
        Thread.__init__(self)
        print("Check thread started")

    def run(self):
        global new_client
        global break_all
        global dict
        while True:
            i = 0
            while i < len(dict):
                time.sleep(.5)
                if len(dict) != 0:
                    try:
                        soc = list(dict.values())[i]
                        message = "test"
                    except:
                        print('index error. Resetting check')
                        i = 0
                    try:
                        soc.send(message.encode("utf-8"))
                    except:
                        #new_client = False
                        print(dict)
                        print('closing connection to ' + str(list(dict.keys())[i]))
                        key = list(dict.keys())[i]
                        sock = list(dict.values())[i]
                        del dict[key]
                        print(dict)
                        try:
                            sel.unregister(sock)
                            sock.close()
                            i = 0
                        except:
                            print('unable to close sock' + str(sock))
                    i += 1
                    '''except:
                        print('An unexpected error occured. Please restart the program...')
                        i = 0
                        while i < len(dict):
                            check = list(dict.values())[i]
                            if str(check).__contains__('[closed]'):
                                print('problem found')
                                print(str(check))
                                key = list(dict.keys())[i]
                                print(key)
                                print(dict)
                                del dict[key]
                                print(dict)
                                press('enter')
                                i = len(dict)
                            i+=1'''

                    '''break_all = True
                                            print('breaking Check2')
                                            time.sleep(6)
                                            press('enter')
                                            #os.system('backup.py')
                                            return'''


a = Starter()
b = Send()
c = Check()
d = Check2()
a.start()

while connected == False:
    time.sleep(.1)

if connected == True:
    print("Send started")
    b.start()
    c.start()
    d.start()